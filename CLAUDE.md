# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

LessUI-Cores is a build system for creating CPU-optimized libretro emulator cores for ARM-based retro handhelds running MinUI. It generates ~25-27 cores per CPU family, supporting 35 retro gaming systems.

**Key Architecture Principle:** Systems-driven, not cores-driven. You define which retro systems to support in `config/systems.yml`, and the build system automatically determines which cores to build for each CPU family, using production-tested commits from Knulli.

## Common Build Commands

```bash
# Generate core lists from systems.yml (run after editing systems)
make recipes-cortex-a53
make recipes-all

# Build cores for specific CPU family
make build-cortex-a7    # ARM32: Miyoo Mini family
make build-cortex-a53   # ARM64: Universal baseline (RG35xx, RG40xx, Trimui)
make build-cortex-a55   # ARM64: RK3566 optimized (Miyoo Flip, RGB30, RG353)
make build-cortex-a76   # ARM64: High-performance (RG406/556, Retroid Pocket 5)

# Build all families (1-3 hours per family)
make build-all

# Build single core for testing/debugging
make core-cortex-a53-gambatte
make core-cortex-a55-flycast

# Package builds
make package-cortex-a53
make package-all

# Clean
make clean              # Clean all build outputs
make clean-cortex-a53   # Clean specific CPU family
```

## Build System Architecture

### Three-Phase Build Flow

The build system operates in three distinct phases:

**Phase 1: System Configuration → Core Lists**
- **Input:** `config/systems.yml` (defines retro systems and per-CPU core mappings)
- **Script:** `scripts/generate-cores-from-systems`
- **Output:** `config/cores-{cpu}.list` (unique cores needed for that CPU family)
- **Example:** SNES uses `pocketsnes` on cortex-a7, `snes9x` on a53/a55, `bsnes` on a76

**Phase 2: Core Lists → Build Recipes**
- **Input:** `config/cores-{cpu}.list` + Knulli `.mk` files
- **Script:** `scripts/generate-recipes`
- **Library:** `lib/mk_parser.rb` (parses Knulli's Buildroot `.mk` files)
- **Output:** `recipes/linux/{cpu}.json` (git URLs, tested commit hashes, build configs)
- **Key:** Uses production-proven commits from Knulli's real hardware testing

**Phase 3: Recipes → Built Cores**
- **Input:** `recipes/linux/{cpu}.json` + CPU config files
- **Script:** `scripts/build-all`
- **Libraries:** `lib/cores_builder.rb` (orchestrator), `lib/core_builder.rb` (per-core builds)
- **Output:** `output/{cpu}/*.so` files (compiled cores)
- **Process:** Fetches sources, cross-compiles with CPU-optimized flags, outputs .so files

### Ruby Library Organization

- **`lib/cores_builder.rb`** - Main orchestrator; coordinates all three phases
- **`lib/cpu_config.rb`** - Parses `config/{cpu}.config` bash files into Ruby objects
- **`lib/mk_parser.rb`** - Parses Knulli's `.mk` files to extract git repos, commits, build commands
- **`lib/recipe_generator.rb`** - Generates JSON recipes from parsed .mk data
- **`lib/source_fetcher.rb`** - Clones/fetches git repositories at specific commits
- **`lib/core_builder.rb`** - Executes builds for individual cores
- **`lib/logger.rb`** - Centralized logging with sections and timestamps

### Data Flow

```
systems.yml → generate-cores-from-systems → cores-*.list
                                                ↓
cores-*.list + knulli/*.mk → generate-recipes → recipes/linux/*.json
                                                    ↓
recipes/linux/*.json → build-all → output/{cpu}/*.so
```

## Key Configuration Files

### `config/systems.yml` - Source of Truth

This is the **only file you should edit** to add/remove systems. Structure:

```yaml
system_id:
  name: Display Name
  cores:
    default: core-name        # Used unless CPU-specific override exists
    cortex-a7: lightweight    # Optional: ARM32 override (or null to exclude)
    cortex-a53: balanced      # Optional: mid-range ARM64 override
    cortex-a76: accurate      # Optional: high-end override
```

Core selection philosophy:
- **cortex-a7:** Lightweight cores for weak ARM32 devices (pocketsnes, stella2014, gpsp)
- **cortex-a53/a55:** Balance of accuracy and performance
- **cortex-a76:** Cycle-accurate/heavy cores where beneficial (bsnes, swanstation, beetle)

### `config/{cpu}.config` - CPU-Specific Compiler Flags

Bash-formatted files with CPU-optimized compiler flags. Key variables:
- `ARCH` - Architecture (arm, aarch64)
- `TARGET_CROSS` - Compiler prefix (arm-linux-gnueabihf-, aarch64-linux-gnu-)
- `TARGET_OPTIMIZATION` - CPU-specific march/mcpu/mtune flags
- `TARGET_CFLAGS` / `TARGET_CXXFLAGS` - Compiler optimization flags

**Do not edit these unless you understand ARM CPU architecture specifics.**

### Generated Files (Do Not Edit Directly)

- `config/cores-*.list` - Generated by `generate-cores-from-systems`
- `recipes/linux/*.json` - Generated by `generate-recipes`

## Adding New Systems

1. **Edit `config/systems.yml`:**
   ```yaml
   wonderswan:
     name: Bandai WonderSwan
     cores:
       default: beetle-wswan
       cortex-a7: null  # Exclude from ARM32
   ```

2. **Regenerate core lists and recipes:**
   ```bash
   make recipes-all
   ```

3. **Build:**
   ```bash
   make build-cortex-a53  # Or build-all
   ```

The system will automatically fetch the core from Knulli's definitions.

## Updating Cores from Knulli

When Knulli updates their core definitions or commits:

```bash
# Update Knulli submodule to latest
git submodule update --remote knulli

# Regenerate recipes with latest commits
make recipes-all

# Rebuild cores
make build-all
```

This pulls the latest tested commits from Knulli's production builds.

## Build Environment

- **Docker:** Debian Buster (for glibc 2.28 compatibility)
- **Compiler:** GCC 8.3.0
- **Toolchains:** arm-linux-gnueabihf (ARM32), aarch64-linux-gnu (ARM64)
- **Parallel builds:** Controlled by `-j` flag or `JOBS` environment variable

## CPU Family Details

| CPU Family | Architecture | Devices | Core Selection Strategy |
|------------|--------------|---------|------------------------|
| **cortex-a7** | ARM32 (ARMv7) | Miyoo Mini, A30 | Lightweight cores, exclude heavy systems (N64, NDS, PSP) |
| **cortex-a53** | ARM64 (ARMv8-a) | RG28xx/35xx/40xx, Trimui | Universal baseline, balanced cores |
| **cortex-a55** | ARM64 (ARMv8.2-a) | Miyoo Flip, RGB30, RG353 | RK3566-optimized, crypto+dotprod extensions |
| **cortex-a76** | ARM64 (ARMv8.2-a) | RG406/556, Retroid Pocket 5 | High-performance, cycle-accurate cores |

## Troubleshooting

### Build Failures

1. Check build log: `output/logs/{cpu}-build.log`
2. Test single core: `make core-cortex-a53-{corename}`
3. Verify recipe exists: `cat recipes/linux/{cpu}.json | jq '.[] | select(.name=="{corename}")'`

### Missing Cores

1. Verify core exists in Knulli: `find knulli/package -name "libretro-{corename}.mk"`
2. Check if core is in generated list: `cat config/cores-{cpu}.list`
3. Regenerate recipes: `make recipes-{cpu}`

### Cross-Compilation Issues

- Ensure Docker image is built: `make docker-build`
- Check CPU config file exists: `config/{cpu}.config`
- Verify toolchain is available in Docker container: `make shell`

## Output Structure

```
output/
├── cores/              # Fetched source code (git clones)
├── logs/               # Build logs
├── dist/               # Packaged zips
├── cortex-a7/*.so      # ARM32 cores (25 cores)
├── cortex-a53/*.so     # ARM64 baseline (26 cores)
├── cortex-a55/*.so     # RK3566 optimized (26 cores)
└── cortex-a76/*.so     # High-performance (27 cores)
```

## Development Workflow

### Testing a New Core

```bash
# 1. Add system to systems.yml
# 2. Generate recipe for one CPU family
make recipes-cortex-a53

# 3. Build just that core
make core-cortex-a53-{corename}

# 4. If successful, build for all families
make recipes-all
make build-all
```

### Debugging Build Issues

```bash
# Open shell in build container
make shell

# Manually inspect source
cd output/cores/{corename}
ls -la

# Try manual build with verbose output
make -f Makefile.libretro platform=unix CC=gcc
```

## Release and Deployment

### Creating a Release

The project uses git flow with automated releases triggered by UTC date-based tags (YYYYMMDD format):

```bash
# Create a new release (must be on develop branch)
./scripts/release

# Force re-release (overwrites existing tag/release for today)
./scripts/release --force
```

The release script will:
1. Validate you're on the `develop` branch with no uncommitted changes
2. Generate a UTC date-based tag (e.g., `20251115`)
3. If tag exists and `--force` flag used, delete local/remote tag and GitHub release
4. Execute git flow release start/finish
5. Push branches and tag to trigger GitHub Actions

**Force Mode:** Use `--force` to redeploy on the same day (e.g., after fixing a bad build). This deletes the existing tag and GitHub release (requires `gh` CLI for release deletion).

### GitHub Actions Workflow

When a tag matching YYYYMMDD format is pushed to `main`:
1. Builds Docker image
2. Runs `make build-all` for all CPU families
3. Packages builds using `make package-all`
4. Creates GitHub Release with:
   - `cortex-a7.zip` - ARM32 cores
   - `cortex-a53.zip` - ARM64 baseline cores
   - `cortex-a55.zip` - RK3566 optimized cores
   - `cortex-a76.zip` - High-performance cores
5. Updates `latest` tag to point to newest release

### Prerequisites for Deployment

- git-flow must be installed: `brew install git-flow` (macOS) or `apt-get install git-flow` (Linux)
- Repository must be on `develop` branch
- All changes must be committed
- GitHub repository must have Actions enabled

## Important Notes

- **Never commit `output/` directory** - It contains build artifacts and fetched sources
- **The Knulli submodule is critical** - All core definitions and commits come from it
- **Each CPU family needs ~5GB disk space** - Plan accordingly
- **Build times are 1-3 hours per CPU family** - Use `build-all` overnight
- **Generated files are deterministic** - If you edit systems.yml, always regenerate recipes
- **One release per day** - UTC date tags prevent multiple releases on the same day
